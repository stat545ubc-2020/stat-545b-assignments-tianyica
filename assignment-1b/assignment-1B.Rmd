---
title: "Assignment 1-B"
subtitle: "Version 1.0" 
output: github_document
author: Tianyi Zheng
---

Loading Packages
```{r,message=FALSE,warning=FALSE}
library(tidyverse)
library(gapminder)
library(testthat)
library(broom)
```


## Exercise 1: Functions (10 points)

### 1.1 Documentation and Design (5)
<!----------- Documentation goes here ---------------------->

**Description**

This function takes a dataset(as a list) of two quantitative variables and fits a single linear regression model from the them,then it displays a scatterplot with fitted regression line. Also, it displays any influential points as color red based on user defined critiria (cut-off for cook's distance).

**Input (Arguments)**

- `data`: a list(dataframe, tibble, etc...) with two quantitative variables.
  - _Justification_: Data means the data that would be used to fit the model and made the plot. There is no default value of data. 
- `xy`: logicals. If TRUE then the first column of the dataframe would assumed to be independent variable, and vice versa for FALSE. The default if TRUE.
  - _Justification_: xy means the first column is the independent variable in the regression model, and the second column is the dependent variable. The default is TRUE, which only indicate one of the two possibilties. 
- `cooksd`: a non-negative numercial value for cook's distance threshold. The default is 0.5.
  - _Justification_: Cooksd means the Cook's Distance for identifying influential observations. Emprically, a cook's distance above 0.5 would need to be examine, so the default is 0.5.
- `na.action`: a function which indicates what should happen when the data contain NAs. The default is set by the na.action setting of options, and is na.fail if that is unset. 
  - _Justification_: Na.action means default actions for NA values, and the default setting is as what is in options.
  - `verbose`: logicals. If TRUE then print a message on the count of influential observations.
  - _Justification_: Verbose, and the default is FALSE because it would not print additional message unless user requested.
- `...`: additional arguments to be passed to the low level regression fitting functions. 
  - _Justification_: The ellipsis allows for more generalizability.

**Output**

A scatterplot with fitted regression line, and red labelled influential points. 

<!---------------------------------------------------------->



### 1.2 Write the Function (3)
<!------------ Write your function below here -------------->
```{r}
  if(typeof(data)!="list"){
    stop('The function expect input data as list\n',
         'but the input is: ', typeof(data)[1])
  }
  if(ncol(data)!=2){
    stop('The function expect two columns\n',
         'but the input has: ', ncol(data))
  }
  if(!is.numeric(data[[1]])|!is.numeric(data[[2]])){
    stop('The function expect quantinative/numberic variables.')
  }
  if(!is.numeric(cooksd)|cooksd<0){
    stop('cooksd needs to be a non-negative number')
  }

data %>% 
  mutate(Infob=cooks.distance(model)>cooksd) %>% 
  ggplot(aes(x,y))+
  geom_point(aes(color=Infob))+
  geom_smooth(method=lm, se=FALSE)+
  scale_color_manual(values=c("Black", "Red"))+ 
  theme_bw()+
  theme(legend.position = "none")
```

```{r}
scatterinfobs<-function(data, xy=TRUE, cooksd=0.5, ...){
model<-lm(data[[2]]~data[[1]],...)
summary(model)
}
```


```{r}
test<-gapminder %>% 
  select(pop,gdpPercap)
```


```{r}
model<-lm(test[[2]]~test[[1]])
```

```{r}
test %>% 
  mutate(Infob=cooks.distance(model)>0.01
  ) %>% 
  ggplot(aes(pop,gdpPercap))+
  geom_point(aes(color=Infob))+
  geom_smooth(method=lm, se=FALSE)+
  scale_color_manual(values=c("Black", "Red"))+
  theme_bw()+
  theme(legend.position = "none")
```

<!---------------------------------------------------------->



### 1.3 Test the Function (2 points)

<!------------ Test your function below here --------------->
```{r}
scatterinfobs(gapminder %>% 
                select(lifeExp,pop))
scatterinfobs(gapminder %>% 
                select(pop,gdpPercap))
```

```{r}
expect_error(scatterinfobs(data=gapminder %>% 
                select(country,pop)))
expect_error(scatterinfobs(data=gapminder %>% 
                select(year,country,pop)))
expect_error(scatterinfobs(data=FALSE))
expect_error(scatterinfobs(data=gapminder %>% 
                select(country,pop),cooksd = "0.5"))
```

<!---------------------------------------------------------->
-------

## Exercise 2: List Columns (8 points)

### 2.1 (8 points) 
<!------------ Put your work here -------------------------->
Check Gapminder Dataset
```{r}
head(gapminder)
```

1. Create linear regression model column for each continent, to regress lifeExp and pop on gdpPercap
```{r}
(gdpmodelPerContinent<-gapminder %>% 
  select(continent,lifeExp,pop,gdpPercap) %>% 
  nest(data=c(lifeExp,pop,gdpPercap)) %>% 
  mutate(model= map(data, ~{
    lm(gdpPercap~lifeExp+pop,data = .x)
  })))
  
```
2. Evaluate the model by getting the linear model coefficient into its seprate column
```{r}
gdpCoef<-gdpmodelPerContinent %>% 
  mutate(coef= map(model, tidy))
```
3. Print out the tibble so far.
```{r}
gdpCoef
```
4. Unnest the coef column, and only keep relevant columns and the statistically significant (p-value less than 0.05) non-intercept terms.
```{r}
gdpCoef %>% 
  unnest(coef) %>% 
  select(continent,model,term,p.value) %>% 
  filter(p.value<0.05) %>% 
  filter(term!="(Intercept)") 
```
5.Brief explaination:
The final tibble in 4 shows the linear regression model (in the model column) result that regress lifeExp(life expectancy) and pop(population) on gdpPercap (GDP per capita) per continent. The final tibble only kept statistically significant (p-value less than 0.05 in p.value column) non-intercept terms(in the term column).
<!---------------------------------------------------------->


### 2.2 (**Optional**, 1 bonus point)

Here, we still fit the model in the previous part, which regress lifeExp(life expectancy) and pop(population) on gdpPercap (GDP per capita). From the cook's distance plot, we can identify that record 853,854,857 are infuenltial observations. After looking up, those records belong to Kuwait.
Kuwait is an interesting country in this case because althought it is not the country with highest life expectancy or population, it has the highest GDP per capita, in fact, more than twice for any other countries in the gapminder dataset.
```{r}
model<-lm(gdpPercap~lifeExp+pop,data=gapminder)
plot(model)
gapminder[c(853,854,857),]
gapminder %>% 
  group_by(country) %>% 
  summarise(lifeExp=mean(lifeExp),pop=mean(pop),gdpPercap=mean(gdpPercap)) %>% 
  arrange(desc(gdpPercap))
```
